===================================================================
--- Current Version
+++ New Version
@@ -1,51 +1,35 @@
 // ==UserScript==
-// @name Krunker SkidFest
-// @description A full featured Mod menu for game Krunker.io!
-// @version 2.00
-// @author SkidLamer - From The Gaming Gurus
-// @supportURL https://discord.gg/2uqj5Y6h7s
-// @homepage https://skidlamer.github.io/
-// @icon64 https://i.imgur.com/PPGAhg0.png
-// @match *.krunker.io/*
-// @exclude *krunker.io/social*
-// @updateURL https://skidlamer.github.io/js/Skidfest.user.js
-// @run-at document-start
-// @grant none
+// @name          Krunker SkidFest
+// @description   A full featured Mod menu for game Krunker.io!
+// @version       2.19
+// @author        SkidLamer - From The Gaming Gurus
+// @supportURL    https://discord.gg/AJFXXACdrF
+// @homepage      https://skidlamer.github.io/
+// @iconURL       https://i.imgur.com/MqW6Ufx.png
+// @match         *://krunker.io/*
+// @exclude       *://krunker.io/editor*
+// @exclude       *://krunker.io/social*
+// @updateURL     https://skidlamer.github.io/js/Skidfest.user.js
+// @run-at        document-start
+// @grant         none
 // @noframes
 // ==/UserScript==
 
-const isProxy = Symbol("isProxy");
-const original_Proxy = window.Proxy;
-const original_Reflect= window.Reflect;
-const original_fetch = window.fetch;
-const original_Object = window.Object;
-const original_Promise = window.Promise;
-const original_Function = window.Function;
-const original_MutationObserver = window.MutationObserver;
-const original_decode = window.TextDecoder.prototype.decode;
-const original_clearRect = window.CanvasRenderingContext2D.prototype.clearRect;
-const original_save = window.CanvasRenderingContext2D.prototype.save;
-const original_scale = window.CanvasRenderingContext2D.prototype.scale;
-const original_beginPath = window.CanvasRenderingContext2D.prototype.beginPath;
-const original_moveTo = window.CanvasRenderingContext2D.prototype.moveTo;
-const original_lineTo = window.CanvasRenderingContext2D.prototype.lineTo;
-const original_stroke = window.CanvasRenderingContext2D.prototype.stroke;
-const original_fillRect = window.CanvasRenderingContext2D.prototype.fillRect;
-const original_fillText = window.CanvasRenderingContext2D.prototype.fillText;
-const original_strokeText = window.CanvasRenderingContext2D.prototype.strokeText;
-const original_restore = window.CanvasRenderingContext2D.prototype.restore;
-const key = { frame: 0, delta:1,xdir:2,ydir:3,moveDir:4,shoot:5,scope:6,jump:7,reload:8,crouch:9,weaponScroll:10,weaponSwap:11, moveLock:12}
-//original_Object.assign(console, { log:_=>{}, dir:_=>{}, groupCollapsed:_=>{}, groupEnd:_=>{} });
 /* eslint-env es6 */
-/* eslint-disable no-caller, no-undef */
+/* eslint-disable no-caller, no-undef, no-loop-func */
 
-class Utilities {
-    constructor(script) {
-        this.script = script;
+var CRC2d = CanvasRenderingContext2D.prototype;
+var skid, skidStr = [...Array(8)].map(_ => 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'[~~(Math.random()*52)]).join('');
+
+class Skid {
+    constructor() {
+        skid = this;
         this.downKeys = new Set();
         this.settings = null;
         this.vars = {};
+        this.playerMaps = [];
+        this.skinCache = {};
         this.inputFrame = 0;
         this.renderFrame = 0;
         this.fps = 0;
         this.lists = {
@@ -116,23 +100,38 @@
             recoilMlt: 0.3,
             nameOffset: 0.6,
             nameOffsetHat: 0.8,
         };
+        this.key = {
+            frame: 0,
+            delta: 1,
+            xdir: 2,
+            ydir: 3,
+            moveDir: 4,
+            shoot: 5,
+            scope: 6,
+            jump: 7,
+            reload: 8,
+            crouch: 9,
+            weaponScroll: 10,
+            weaponSwap: 11,
+            moveLock: 12
+        };
         this.css = {
             noTextShadows: `*, .button.small, .bigShadowT { text-shadow: none !important; }`,
             hideAdverts: `#aMerger, #endAMerger { display: none !important }`,
             hideSocials: `.headerBarRight > .verticalSeparator, .imageButton { display: none }`,
             cookieButton: `#onetrust-consent-sdk { display: none !important }`,
             newsHolder: `#newsHolder { display: none !important }`,
         };
+        this.isProxy = Symbol("isProxy");
         this.spinTimer = 1800;
-        this.skinConfig = {};
         let wait = setInterval(_ => {
             this.head = document.head||document.getElementsByTagName('head')[0]
             if (this.head) {
                 clearInterval(wait);
-                original_Object.entries(this.css).forEach(entry => {
-                    this.css[entry[0]] = this.createElement("style", entry[1])
+                Object.entries(this.css).forEach(entry => {
+                    this.css[entry[0]] = this.createElement("style", entry[1]);
                 })
                 this.onLoad();
             }
         }, 100);
@@ -174,32 +173,44 @@
         return "https://crossorigin.me/" + url;
     }
 
     async waitFor(test, timeout_ms = 20000, doWhile = null) {
-        let sleep = (ms) => new original_Promise((resolve) => setTimeout(resolve, ms));
-        return new original_Promise(async (resolve, reject) => {
+        let sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
+        return new Promise(async (resolve, reject) => {
             if (typeof timeout_ms != "number") reject("Timeout argument not a number in waitFor(selector, timeout_ms)");
             let result, freq = 100;
             while (result === undefined || result === false || result === null || result.length === 0) {
-                if (doWhile && doWhile instanceof original_Function) doWhile();
+                if (doWhile && doWhile instanceof Function) doWhile();
                 if (timeout_ms % 1000 < freq) console.log("waiting for: ", test);
                 if ((timeout_ms -= freq) < 0) {
                     console.log( "Timeout : ", test );
                     resolve(false);
                     return;
                 }
                 await sleep(freq);
-                result = typeof test === "string" ? original_Function(test)() : test();
+                result = typeof test === "string" ? Function(test)() : test();
             }
             console.log("Passed : ", test);
             resolve(result);
         });
     };
 
     createSettings() {
         this.settings = {
+            //Rendering
+            showSkidBtn: {
+                pre: "<div class='setHed'>Rendering</div>",
+                name: "Show Skid Button",
+                val: true,
+                html: () => this.generateSetting("checkbox", "showSkidBtn", this),
+                set: (value, init) => {
+                    let button = document.getElementById("mainButton");
+                    if (!button) {
+                        button = this.createButton("5k1D", "https://i.imgur.com/1tWAEJx.gif", this.toggleMenu, value)
+                    } else button.style.display = value ? "inherit" : "none";
+                }
+            },
             hideAdverts: {
-                pre: "<div class='setHed'>Rendering</div>",
                 name: "Hide Advertisments",
                 val: true,
                 html: () => this.generateSetting("checkbox", "hideAdverts", this),
                 set: (value, init) => {
@@ -301,8 +312,9 @@
                     "customBillboard",
                     "Custom Billboard Text"
                 ),
             },
+            //Weapon
             autoReload: {
                 pre: "<br><div class='setHed'>Weapon</div>",
                 name: "Auto Reload",
                 val: false,
@@ -324,22 +336,23 @@
                 val: false,
                 html: () => this.generateSetting("checkbox", "wallPenetrate"),
             },
             weaponZoom: {
-				name: "Weapon Zoom",
-				val: 1.0,
-				min: 0,
-				max: 50.0,
-				step: 0.01,
-				html: () => this.generateSetting("slider", "weaponZoom"),
-				set: (value) => { if (this.renderer) this.renderer.adsFovMlt = value;}
-			},
+                name: "Weapon Zoom",
+                val: 1.0,
+                min: 0,
+                max: 50.0,
+                step: 0.01,
+                html: () => this.generateSetting("slider", "weaponZoom"),
+                set: (value) => { if (this.renderer) this.renderer.adsFovMlt = value;}
+            },
             weaponTrails: {
                 name: "Weapon Trails",
                 val: false,
                 html: () => this.generateSetting("checkbox", "weaponTrails"),
                 set: (value) => { if (this.me) this.me.weapon.trail = value;}
             },
+            //Player
             autoBhop: {
                 pre: "<br><div class='setHed'>Player</div>",
                 name: "Auto Bhop Type",
                 val: "off",
@@ -358,14 +371,20 @@
                 name: "Unlock Skins",
                 val: false,
                 html: () => this.generateSetting("checkbox", "skinUnlock", this),
             },
+            //GamePlay
             disableWpnSnd: {
                 pre: "<br><div class='setHed'>GamePlay</div>",
                 name: "Disable Players Weapon Sounds",
                 val: false,
                 html: () => this.generateSetting("checkbox", "disableWpnSnd", this),
             },
+            disableHckSnd: {
+                name: "Disable Hacker Fart Sounds",
+                val: false,
+                html: () => this.generateSetting("checkbox", "disableHckSnd", this),
+            },
             autoActivateNuke: {
                 name: "Auto Activate Nuke",
                 val: false,
                 html: () => this.generateSetting("checkbox", "autoActivateNuke", this),
@@ -384,8 +403,9 @@
                 name: "No InActivity Kick",
                 val: true,
                 html: () => this.generateSetting("checkbox", "autoClick", this),
             },
+            //Radio Stream Player
             playStream: {
                 pre: "<br><div class='setHed'>Radio Stream Player</div>",
                 name: "Stream Select",
                 val: "off",
@@ -430,45 +450,16 @@
                 },
                 audio: null,
             },
             audioVolume: {
-				name: "Radio Volume",
-				val: 0.5,
-				min: 0,
-				max: 1,
-				step: 0.01,
-				html: () => this.generateSetting("slider", "audioVolume"),
-				set: (value) => { if (this.settings.playStream.audio) this.settings.playStream.audio.volume = value;}
-			},
-
-            /*
-            Alternate Howler Sound
-            playSound: {
-                name: "Sound Player",
-                val: "",
-                html: () => `<hr><audio controls><source src='window.utilities.settings.playSound.sound.src'/></audio>` + this.generateSetting("url", "playSound", "URL to Sound file"),
-                sound: null,
-                set: (value, init) => {
-                    //if ( value && value.startsWith("http") && (value.endsWith(".webm") || value.endsWith(".mp3") || value.endsWith(".wav")) ) {
-                        //this.settings.playSound.sound = new window.Howl({src: value, autoplay: true, loop: true, volume: 1.0, rate: 1.0})
-                   //
-                   // if (init) {
-                    //    if ( value.startsWith("http") && (value.endsWith(".webm") || value.endsWith(".mp3") || value.endsWith(".wav")) ) {
-                      //       let proxy = 'https://cors-anywhere.herokuapp.com/';
-                       //      let url = proxy + value;
-                       //     try {
-                        //        this.settings.playSound.sound = new window.Howl({src: value, autoplay: true, loop: true, volume: 1.0, rate: 1.0})
-                         //   } catch(e) {
-                          //      console.error(e)
-                          //      this.settings.playSound.sound = null
-                          //  }
-                        } else if (value) {
-                            alert("Sound file MUST be a .MP3, .webm or .wav !!")
-                            value = "";
-                        }
-                   // }
-                }
-            },*/
+                name: "Radio Volume",
+                val: 0.5,
+                min: 0,
+                max: 1,
+                step: 0.01,
+                html: () => this.generateSetting("slider", "audioVolume"),
+                set: (value) => { if (this.settings.playStream.audio) this.settings.playStream.audio.volume = value;}
+            },
         };
 
         // Inject Html
         let waitForWindows = setInterval(_ => {
@@ -481,21 +472,21 @@
                         if (this.settings[key].pre) tmpHTML += this.settings[key].pre;
                         tmpHTML += "<div class='settName' id='" + key + "_div' style='display:" + (this.settings[key].hide ? 'none' : 'block') + "'>" + this.settings[key].name +
                             " " + this.settings[key].html() + "</div>";
                     }
-                    tmpHTML += `<br><hr><a onclick='window.utilities.resetSettings()' class='menuLink'>Reset Settings</a> | <a onclick='window.utilities.saveScript()' class='menuLink'>Save GameScript</a>`
-                   /// tmpHTML += `<audio controls><source src='window.utilities.settings.playSound.sound.src'/></audio>`
+                    tmpHTML += `<br><hr><a onclick='${skidStr}.resetSettings()' class='menuLink'>Reset Settings</a> | <a onclick='${skidStr}.saveScript()' class='menuLink'>Save GameScript</a>`
                     return tmpHTML;
                 };
                 clearInterval(waitForWindows);
+                //this.createButton("5k1D", "https://i.imgur.com/1tWAEJx.gif", this.toggleMenu)
             }
         }, 100);
 
         // setupSettings
         for (const key in this.settings) {
             this.settings[key].def = this.settings[key].val;
             if (!this.settings[key].disabled) {
-                let tmpVal = this.getSavedVal(`kro_utilities_${key}`);
+                let tmpVal = this.getSavedVal(key);
                 this.settings[key].val = tmpVal !== null ? tmpVal : this.settings[key].val;
                 if (this.settings[key].val == "false") this.settings[key].val = false;
                 if (this.settings[key].val == "true") this.settings[key].val = true;
                 if (this.settings[key].val == "undefined") this.settings[key].val = this.settings[key].def;
@@ -506,37 +497,38 @@
 
     generateSetting(type, name, extra) {
         switch (type) {
             case 'checkbox':
-                return `<label class="switch"><input type="checkbox" onclick="window.utilities.setSetting('${name}', this.checked)" ${this.settings[name].val ? 'checked' : ''}><span class="slider"></span></label>`;
+                return `<label class="switch"><input type="checkbox" onclick="${skidStr}.setSetting('${name}', this.checked)" ${this.settings[name].val ? 'checked' : ''}><span class="slider"></span></label>`;
             case 'slider':
-                return `<span class='sliderVal' id='slid_utilities_${name}'>${this.settings[name].val}</span><div class='slidecontainer'><input type='range' min='${this.settings[name].min}' max='${this.settings[name].max}' step='${this.settings[name].step}' value='${this.settings[name].val}' class='sliderM' oninput="window.utilities.setSetting('${name}', this.value)"></div>`
+                return `<span class='sliderVal' id='slid_utilities_${name}'>${this.settings[name].val}</span><div class='slidecontainer'><input type='range' min='${this.settings[name].min}' max='${this.settings[name].max}' step='${this.settings[name].step}' value='${this.settings[name].val}' class='sliderM' oninput="${skidStr}.setSetting('${name}', this.value)"></div>`
                 case 'select': {
-                    let temp = `<select onchange="window.utilities.setSetting(\x27${name}\x27, this.value)" class="inputGrey2">`;
+                    let temp = `<select onchange="${skidStr}.setSetting(\x27${name}\x27, this.value)" class="inputGrey2">`;
                     for (let option in extra) {
                         temp += '<option value="' + option + '" ' + (option == this.settings[name].val ? 'selected' : '') + '>' + extra[option] + '</option>';
                     }
                     temp += '</select>';
                     return temp;
                 }
             default:
-                return `<input type="${type}" name="${type}" id="slid_utilities_${name}"\n${'color' == type ? 'style="float:right;margin-top:5px"' : `class="inputGrey2" placeholder="${extra}"`}\nvalue="${this.settings[name].val}" oninput="window.utilities.setSetting(\x27${name}\x27, this.value)"/>`;
+                return `<input type="${type}" name="${type}" id="slid_utilities_${name}"\n${'color' == type ? 'style="float:right;margin-top:5px"' : `class="inputGrey2" placeholder="${extra}"`}\nvalue="${this.settings[name].val}" oninput="${skidStr}.setSetting(\x27${name}\x27, this.value)"/>`;
         }
     }
 
     resetSettings() {
         if (confirm("Are you sure you want to reset all your settings? This will also refresh the page")) {
-            original_Object.keys(localStorage).filter(x => x.includes("kro_utilities_")).forEach(x => localStorage.removeItem(x));
+            Object.keys(localStorage).filter(x => x.includes("kro_utilities_")).forEach(x => localStorage.removeItem(x));
             location.reload();
         }
     }
 
     setSetting(t, e) {
         this.settings[t].val = e;
-        this.saveVal(`kro_utilities_${t}`, e);
+        this.saveVal(t, e);
         if (document.getElementById(`slid_utilities_${t}`)) document.getElementById(`slid_utilities_${t}`).innerHTML = e;
         if (this.settings[t].set) this.settings[t].set(e);
     }
+
     createObserver(elm, check, callback, onshow = true) {
         return new MutationObserver((mutationsList, observer) => {
             if (check == 'src' || onshow && mutationsList[0].target.style.display == 'block' || !onshow) {
                 callback(mutationsList[0].target);
@@ -551,20 +543,47 @@
         }
         elm.addEventListener(type, event => callback(event));
     }
 
-    createElement(type, html, id) {
-        let newElement = document.createElement(type)
-        if (id) newElement.id = id
-        newElement.innerHTML = html
-        return newElement
+    createElement(element, attribute, inner) {
+        if (!this.isDefined(element)) {
+            return null;
+        }
+        if (!this.isDefined(inner)) {
+            inner = "";
+        }
+        let el = document.createElement(element);
+        if (this.isType(attribute, 'object')) {
+            for (let key in attribute) {
+                el.setAttribute(key, attribute[key]);
+            }
+        }
+        if (!Array.isArray(inner)) {
+            inner = [inner];
+        }
+        for (let i = 0; i < inner.length; i++) {
+            if (inner[i].tagName) {
+                el.appendChild(inner[i]);
+            } else {
+                el.appendChild(document.createTextNode(inner[i]));
+            }
+        }
+        return el;
     }
 
-    objectEntries(object, callback) {
-        let descriptors = original_Object.getOwnPropertyDescriptors(object);
-        original_Object.entries(descriptors).forEach(([key, { value, get, set, configurable, enumerable, writable }]) => callback([object, key, value, get, set, configurable, enumerable, writable]));
+    createButton(name, iconURL, fn, visible) {
+        visible = visible ? "inherit":"none";
+        let menu = document.querySelector("#menuItemContainer");
+        let icon = this.createElement("div",{"class":"menuItemIcon", "style":`background-image:url("${iconURL}");display:inherit;`});
+        let title= this.createElement("div",{"class":"menuItemTitle", "style":`display:inherit;`}, name);
+        let host = this.createElement("div",{"id":"mainButton", "class":"menuItem", "onmouseenter":"playTick()", "onclick":"showWindow(12)", "style":`display:${visible};`},[icon, title]);
+        if (menu) menu.append(host)
     }
 
+    objectHas(obj, arr) {
+        return arr.some(prop => obj.hasOwnProperty(prop));
+    }
+
     getVersion() {
         const elems = document.getElementsByClassName('terms');
         const version = elems[elems.length - 1].innerText;
         return version;
@@ -580,9 +599,11 @@
         window.document.body.removeChild(el);
     }
 
     saveScript() {
-        this.saveAs("game_" + this.getVersion() + ".js", this.script)
+        this.fetchScript().then(script => {
+            this.saveAs("game_" + this.getVersion() + ".js", script)
+        })
     }
 
     isKeyDown(key) {
         return this.downKeys.has(key);
@@ -624,10 +645,247 @@
         if (this.isDefined(window.SOUND)) window.SOUND.play(`tick_0`,0.1)
     }
 
     onLoad() {
+
         this.createSettings();
-        this.deObfuscate();
+        this.createObservers();
+
+        this.waitFor(_=>this.isDefined(this.exports)).then(_=> {
+            if (!this.isDefined(this.exports)) {
+                alert("This Mod Needs To Be Updated Please Try Agian Later");
+                return;
+            }
+            //console.dir(this.exports);
+            let toFind = {
+                overlay: ["render", "canvas"],
+                config: ["accAnnounce", "availableRegions", "assetCat"],
+                three: ["ACESFilmicToneMapping", "TextureLoader", "ObjectLoader"],
+                ws: ["socketReady", "ingressPacketCount", "ingressPacketCount", "egressDataSize"],
+                utility: ["VectorAdd", "VectorAngleSign"],
+                //colors: ["challLvl", "getChallCol"],
+                //ui: ["showEndScreen", "toggleControlUI", "toggleEndScreen", "updatePlayInstructions"],
+                //events: ["actions", "events"],
+            }
+            for (let rootKey in this.exports) {
+                let exp = this.exports[rootKey].exports;
+                for (let name in toFind) {
+                    if (this.objectHas(exp, toFind[name])) {
+                        console.log("Found Export ", name);
+                        delete toFind[name];
+                        this[name] = exp;
+                    }
+                }
+            }
+            if (!(Object.keys(toFind).length === 0 && toFind.constructor === Object)) {
+                for (let name in toFind) {
+                    alert("Failed To Find Export " + name);
+                }
+            } else {
+                Object.defineProperty(this.config, "nameVisRate", {
+                    value: 0,
+                    writable: false,
+                    configurable: true,
+                })
+                this.ctx = this.overlay.canvas.getContext('2d');
+                this.overlay.render = new Proxy(this.overlay.render, {
+                    apply: function(target, that, args) {
+                        return [target.apply(that, args), render.apply(that, args)]
+                    }
+                })
+                function render(scale, game, controls, renderer, me) {
+                    let width = skid.overlay.canvas.width / scale;
+                    let height = skid.overlay.canvas.height / scale;
+                    const renderArgs = [scale, game, controls, renderer, me];
+                    if (renderArgs && void 0 !== skid) {
+                        ["scale", "game", "controls", "renderer", "me"].forEach((item, index)=>{
+                            skid[item] = renderArgs[index];
+                        });
+                        if (me) {
+                            skid.ctx.save();
+                            skid.ctx.scale(scale, scale);
+                            //this.ctx.clearRect(0, 0, width, height);
+                            skid.onRender();
+                            //window.requestAnimationFrame.call(window, renderArgs.callee.caller.bind(this));
+                            skid.ctx.restore();
+                        }
+                        if(skid.settings && skid.settings.autoClick.val && window.endUI.style.display == "none" && window.windowHolder.style.display == "none") {
+                            controls.toggle(true);
+                        }
+                    }
+                }
+
+                // Skins
+                const $skins = Symbol("skins");
+                Object.defineProperty(Object.prototype, "skins", {
+                    set: function(fn) {
+                        this[$skins] = fn;
+                        if (void 0 == this.localSkins || !this.localSkins.length) {
+                            this.localSkins = Array.apply(null, Array(5e3)).map((x, i) => {
+                                return {
+                                    ind: i,
+                                    cnt: 0x1,
+                                }
+                            })
+                        }
+                        return fn;
+                    },
+                    get: function() {
+                        return skid.settings.skinUnlock.val && this.stats ? this.localSkins : this[$skins];
+                    }
+                })
+
+                this.waitFor(_=>this.ws.connected === true, 40000).then(_=> {
+                    this.ws.__event = this.ws._dispatchEvent.bind(this.ws);
+                    this.ws.__send = this.ws.send.bind(this.ws);
+                    this.ws.send = new Proxy(this.ws.send, {
+                        apply: function(target, that, args) {
+                            if (args[0] == "ah2") return;
+                            try {
+                                var original_fn = Function.prototype.apply.apply(target, [that, args]);
+                            } catch (e) {
+                                e.stack = e.stack = e.stack.replace(/\n.*Object\.apply.*/, '');
+                                throw e;
+                            }
+
+                            if (args[0] === "en") {
+                                skid.skinCache = {
+                                    main: args[1][2][0],
+                                    secondary: args[1][2][1],
+                                    hat: args[1][3],
+                                    body: args[1][4],
+                                    knife: args[1][9],
+                                    dye: args[1][14],
+                                    waist: args[1][17],
+                                }
+                            }
+
+                            return original_fn;
+                        }
+                    })
+
+                    this.ws._dispatchEvent = new Proxy(this.ws._dispatchEvent, {
+                        apply: function(target, that, [type, event]) {
+                            if (type =="init") {
+                                if(event[10] && event[10].length && event[10].bill && skid.settings.customBillboard.val.length > 1) {
+                                    event[10].bill.txt = skid.settings.customBillboard.val;
+                                }
+                            }
+
+                            if (skid.settings.skinUnlock.val && skid.skinCache && type === "0") {
+                                let skins = skid.skinCache;
+                                let pInfo = event[0];
+                                let pSize = 38;
+                                while (pInfo.length % pSize !== 0) pSize++;
+                                for(let i = 0; i < pInfo.length; i += pSize) {
+                                    if (pInfo[i] === skid.ws.socketId||0) {
+                                        pInfo[i + 12] = [skins.main, skins.secondary];
+                                        pInfo[i + 13] = skins.hat;
+                                        pInfo[i + 14] = skins.body;
+                                        pInfo[i + 19] = skins.knife;
+                                        pInfo[i + 24] = skins.dye;
+                                        pInfo[i + 33] = skins.waist;
+                                    }
+                                }
+                            }
+
+                            return target.apply(that, arguments[2]);
+                        }
+                    })
+                })
+
+                if (this.isDefined(window.SOUND)) {
+                    window.SOUND.play = new Proxy(window.SOUND.play, {
+                        apply: function(target, that, [src, vol, loop, rate]) {
+                            if ( src.startsWith("fart_") && skid.settings.disableHckSnd.val ) return;
+                            return target.apply(that, [src, vol, loop, rate]);
+                        }
+                    })
+                }
+
+                AudioParam.prototype.setValueAtTime = new Proxy(AudioParam.prototype.setValueAtTime, {
+                    apply: function(target, that, [value, startTime]) {
+                        return target.apply(that, [value, 0]);
+                    }
+                })
+
+                this.rayC = new this.three.Raycaster();
+                this.vec2 = new this.three.Vector2(0, 0);
+            }
+        })
+    }
+
+    gameJS(script) {
+        let entries = {
+            // Deobfu
+            inView: { regex: /(\w+\['(\w+)']\){if\(\(\w+=\w+\['\w+']\['position']\['clone']\(\))/, index: 2 },
+            spectating: { regex: /\['team']:window\['(\w+)']/, index: 1 },
+            //inView: { regex: /\]\)continue;if\(!\w+\['(.+?)\']\)continue;/, index: 1 },
+            //canSee: { regex: /\w+\['(\w+)']\(\w+,\w+\['x'],\w+\['y'],\w+\['z']\)\)&&/, index: 1 },
+            //procInputs: { regex: /this\['(\w+)']=function\((\w+),(\w+),\w+,\w+\){(this)\['recon']/, index: 1 },
+            aimVal: { regex: /this\['(\w+)']-=0x1\/\(this\['weapon']\['\w+']\/\w+\)/, index: 1 },
+            pchObjc: { regex: /0x0,this\['(\w+)']=new \w+\['Object3D']\(\),this/, index: 1 },
+            didShoot: { regex: /--,\w+\['(\w+)']=!0x0/, index: 1 },
+            nAuto: { regex: /'Single\\x20Fire','varN':'(\w+)'/, index: 1 },
+            crouchVal: { regex: /this\['(\w+)']\+=\w\['\w+']\*\w+,0x1<=this\['\w+']/, index: 1 },
+            recoilAnimY: { regex: /\+\(-Math\['PI']\/0x4\*\w+\+\w+\['(\w+)']\*\w+\['\w+']\)\+/, index: 1 },
+            //recoilAnimY: { regex: /this\['recoilAnim']=0x0,this\[(.*?\(''\))]/, index: 1 },
+            ammos: { regex: /\['length'];for\(\w+=0x0;\w+<\w+\['(\w+)']\['length']/, index: 1 },
+            weaponIndex: { regex: /\['weaponConfig']\[\w+]\['secondary']&&\(\w+\['(\w+)']==\w+/, index: 1 },
+            isYou: { regex: /0x0,this\['(\w+)']=\w+,this\['\w+']=!0x0,this\['inputs']/, index: 1 },
+            objInstances: { regex: /\w+\['\w+']\(0x0,0x0,0x0\);if\(\w+\['(\w+)']=\w+\['\w+']/, index: 1 },
+            getWorldPosition: { regex: /{\w+=\w+\['camera']\['(\w+)']\(\);/, index: 1 },
+            //mouseDownL: { regex: /this\['\w+'\]=function\(\){this\['(\w+)'\]=\w*0,this\['(\w+)'\]=\w*0,this\['\w+'\]={}/, index: 1 },
+            mouseDownR: { regex: /this\['(\w+)']=0x0,this\['keys']=/, index: 1 },
+            //reloadTimer: { regex:  /this\['(\w+)']&&\(\w+\['\w+']\(this\),\w+\['\w+']\(this\)/, index: 1 },
+            maxHealth: { regex: /this\['health']\/this\['(\w+)']\?/, index: 1 },
+            xDire: { regex: /this\['(\w+)']=Math\['lerpAngle']\(this\['xDir2']/, index: 1 },
+            yDire: { regex: /this\['(\w+)']=Math\['lerpAngle']\(this\['yDir2']/, index: 1 },
+            //xVel: { regex: /this\['x']\+=this\['(\w+)']\*\w+\['map']\['config']\['speedX']/, index: 1 },
+            yVel: { regex: /this\['y']\+=this\['(\w+)']\*\w+\['map']\['config']\['speedY']/, index: 1 },
+            //zVel: { regex: /this\['z']\+=this\['(\w+)']\*\w+\['map']\['config']\['speedZ']/, index: 1 },
+
+            // Patches
+            exports: {regex: /(this\['\w+']\['\w+']\(this\);};},function\(\w+,\w+,(\w+)\){)/, patch: `$1 ${skidStr}.exports=$2.c; ${skidStr}.modules=$2.m;`},
+            inputs: {regex: /(\w+\['\w+']\[\w+\['\w+']\['\w+']\?'\w+':'push']\()(\w+)\),/, patch: `$1${skidStr}.onInput($2)),`},
+            inView: {regex: /&&(\w+\['\w+'])\){(if\(\(\w+=\w+\['\w+']\['\w+']\['\w+'])/, patch: `){if(!$1&&void 0 !== ${skidStr}.nameTags)continue;$2`},
+            thirdPerson:{regex: /(\w+)\[\'config\'\]\[\'thirdPerson\'\]/g, patch: `void 0 !== ${skidStr}.thirdPerson`},
+            isHacker:{regex: /(window\['\w+']=)!0x0\)/, patch: `$1!0x1)`},
+            fixHowler:{regex: /(Howler\['orientation'](.+?)\)\),)/, patch: ``},
+            respawnT:{regex: /'\w+':0x3e8\*/g, patch: `'respawnT':0x0*`},
+            anticheat1:{regex: /&&\w+\(\),window\['utilities']&&\(\w+\(null,null,null,!0x0\),\w+\(\)\)/, patch: ""},
+            anticheat2:{regex: /(\[]instanceof Array;).*?(var)/, patch: "$1 $2"},
+            anticheat3:{regex: /windows\['length'\]>\d+.*?0x25/, patch: `0x25`},
+            commandline:{regex: /Object\['defineProperty']\(console.*?\),/, patch: ""},
+            writeable:{regex: /'writeable':!0x1/g, patch: "writeable:true"},
+            configurable:{regex: /'configurable':!0x1/g, patch: "configurable:true"},
+            typeError:{regex: /throw new TypeError/g, patch: "console.error"},
+            error:{regex: /throw new Error/g, patch: "console.error"},
+        };
+        for(let name in entries) {
+            let object = entries[name];
+            let found = object.regex.exec(script);
+            if (object.hasOwnProperty('index')) {
+                if (!found) {
+                    object.val = null;
+                    alert("Failed to Find " + name);
+                } else {
+                    object.val = found[object.index];
+                    console.log ("Found ", name, ":", object.val);
+                }
+                Object.defineProperty(skid.vars, name, {
+                    configurable: false,
+                    value: object.val
+                });
+            } else if (found) {
+                script = script.replace(object.regex, object.patch);
+                console.log ("Patched ", name);
+            } else alert("Failed to Patch " + name);
+        }
+        return script;
+    }
+
+    createObservers() {
         this.createObserver(window.instructionsUpdate, 'style', (target) => {
             if (this.settings.autoFindNew.val) {
                 console.log(target)
                 if (['Kicked', 'Banned', 'Disconnected', 'Error', 'Game is full'].some(text => target && target.innerHTML.includes(text))) {
@@ -648,9 +906,9 @@
             if ('INPUT' == document.activeElement.tagName || !window.endUI && window.endUI.style.display) return;
             switch (event.code) {
                 case 'NumpadSubtract':
                     document.exitPointerLock();
-                   //console.log(document.exitPointerLock)
+                    //console.log(document.exitPointerLock)
                     console.dirxml(this)
                     break;
                 default:
                     if (!this.downKeys.has(event.code)) this.downKeys.add(event.code);
@@ -667,271 +925,10 @@
                 default:
                     break;
             }
         })
-
-        this.waitFor(_=>this.exports).then(exports => {
-            if (!exports) return alert("Exports not Found");
-            const found = new Set();
-            const array = new Map([
-                ["utility", ["VectorAdd", "VectorAngleSign"]],
-                ["config", ["accAnnounce", "availableRegions", "assetCat"]],
-                ["overlay", ["render", "canvas"]],
-                ["three", ["ACESFilmicToneMapping", "TextureLoader", "ObjectLoader"]],
-                //["colors", ["challLvl", "getChallCol"]],
-                //["ui", ["showEndScreen", "toggleControlUI", "toggleEndScreen", "updatePlayInstructions"]],
-                ["ws", ["socketReady", "ingressPacketCount", "ingressPacketCount", "egressDataSize"]],
-                //["events", ["actions", "events"]],
-            ])
-            return this.waitFor(_ => found.size === array.size, 20000, () => {
-                array.forEach((arr, name, map) => {
-                    this.objectEntries(exports, ([rootObject, rootKey, rootValue, rootGet, rootSet, rootConfigurable, rootEnumerable, rootWritable]) => {
-                        this.objectEntries(rootValue.exports, ([object, key, value, get, set, configurable, enumerable, writable]) => {
-                            if (!found.has(name) && arr.includes(key)) {
-                                found.add(name);
-                                console.log("Found Export ", name);
-                                this[name] = rootValue.exports;
-                            }
-                        })
-                    })
-                })
-            })
-        })
-
-        // Skins
-        const orig_skins = Symbol("orig_skins");
-        original_Object.defineProperty(original_Object.prototype, "skins", {
-            get() {
-                let hacked = window.utilities.settings.skinUnlock.val && this.stats;
-                if (hacked) {
-                    let hack_skins = [];
-                    for(let i = 0; i < 5000; i++) hack_skins.push({ind: i, cnt: 0x1});
-                    return hack_skins;
-                } else return this[orig_skins];
-            }, set(val) {
-                this[orig_skins] = val;
-            },
-            enumerable: false
-        });
-
-        this.waitFor(_=>this.ws.connected === true, 40000).then(_=> {
-            this.ws.__event = this.ws._dispatchEvent.bind(this.ws);
-            this.ws.__send = this.ws.send.bind(this.ws);
-            this.ws.send = new original_Proxy(this.ws.send, {
-                apply(target, that, args) {
-                    try {
-                        var original_fn = Function.prototype.apply.apply(target, [that, args]);
-                    } catch (e) {
-                        e.stack = e.stack = e.stack.replace(/\n.*Object\.apply.*/, '');
-                        throw e;
-                    }
-
-                    if (args[0] === "ah1") {
-                        args[0] = "p";
-                        args[1] = null;
-                    }
-
-                    if (args[0] === "en") {
-                        window.utilities.skinConfig = {
-                            main: args[1][2][0],
-                            secondary: args[1][2][1],
-                            hat: args[1][3],
-                            body: args[1][4],
-                            knife: args[1][9],
-                            dye: args[1][14],
-                            waist: args[1][17],
-                        }
-                    }
-                    return original_fn;
-                   // return target.apply(that, msg);
-                }
-            })
-
-            this.ws._dispatchEvent = new original_Proxy(this.ws._dispatchEvent, {
-                apply(target, that, [type, msg]) {
-                    //console.log(type, msg)
-                    if (type =="init") {
-                        if(msg[9].bill && window.utilities.settings.customBillboard.val.length > 1) {
-                            msg[9].bill.txt = window.utilities.settings.customBillboard.val;
-                        }
-                    }
-                    if (window.utilities.settings.skinUnlock.val && window.utilities.skinConfig && type === "0") {
-                        let playersInfo = msg[0];
-                        let perPlayerSize = 38;
-                        while (playersInfo.length % perPlayerSize !== 0) perPlayerSize++;
-                        for(let i = 0; i < playersInfo.length; i += perPlayerSize) {
-                            if (playersInfo[i] === window.utilities.ws.socketId||0) {
-                                playersInfo[i + 12] = [window.utilities.skinConfig.main, window.utilities.skinConfig.secondary];
-                                playersInfo[i + 13] = window.utilities.skinConfig.hat;
-                                playersInfo[i + 14] = window.utilities.skinConfig.body;
-                                playersInfo[i + 19] = window.utilities.skinConfig.knife;
-                                playersInfo[i + 25] = window.utilities.skinConfig.dye;
-                                playersInfo[i + 33] = window.utilities.skinConfig.waist;
-                            }
-                        }
-                    }
-                    return target.apply(that, arguments[2]);
-                }
-            })
-        })
-
-        if (this.isDefined(window.SOUND)) {
-            window.SOUND.play = new original_Proxy(window.SOUND.play, {
-                apply: function(target, that, [src, vol, loop, rate]) {
-                    if ( src.startsWith("fart_") ) return;
-                    return target.apply(that, [src, vol, loop, rate]);
-                }
-            })
-        }
-
-         //tmpSound = this.sounds[tmpIndx];
-           // if (!tmpSound) {
-             //   tmpSound = new Howl({
-               //     src: ".././sound/" + (window.activeHacker?
-               //         "fart_0":id) + ".mp3"
-              //  });
-              //  this.sounds[tmpIndx] = tmpSound;
-           // }
-
-        //if (this.isDefined(SOUND)) {
-        //    const play = SOUND.play;
-        //    SOUND.play = function() {
-        //       if (arguments[0].startsWith("weapon_")) return;
-        //        return play.apply(this, arguments)
-        //    }
-            //console.dir(window)
-           // chrome.runtime.onMessage.addListener((message, MessageSender, sendResponse)=>{
-          //      console.log(message)
-            //})
-        //}
-
-        // create audio context
-        //var AudioContext = window.AudioContext || window.webkitAudioContext;
-        //var audioCtx = new AudioContext();
-
-        //AudioParam.prototype.setTargetAtTime = new original_Proxy(AudioParam.prototype.setTargetAtTime, {
-        //    apply: function(target, that, [audioTarget, startTime, timeConstant]) {
-        //        let flt = target.apply(that, [audioTarget, startTime, timeConstant]);
-        //        return isFinite(flt) ? flt : 0.0;
-       //     }
-       // })
-
-      //  AudioParam.prototype.setValueAtTime = new original_Proxy(AudioParam.prototype.setValueAtTime, {
-       //     apply: function(target, that, [value, startTime]) {
-       //         return target.apply(that, [value / 100, startTime+1]);
-        //    }
-        // })
-
-        AudioParam.prototype.setValueAtTime = new Proxy(AudioParam.prototype.setValueAtTime, {
-            apply: function(target, that, [value, startTime]) {
-                return target.apply(that, [value, 0]);
-            }
-        })
-
     }
 
-    patchScript() {
-        const patches = new Map()
-        .set("exports", [/(this\['\w+']\['\w+']\(this\);};},function\(\w+,\w+,(\w+)\){)/, `$1 window.utilities.exports=$2.c; window.utilities.modules=$2.m;`])
-        //.set("exports", [/(function\(\w+,\w+,(\w+)\){\(function\(\w+\){)(\w+\['exports'])/,`$1window.utilities.exports=$2.c; window.utilities.modules=$2.m;$3`])
-        //.set("inView", [/if\((!\w+\['\w+'])\)continue;/, "if($1&&void 0 !== window.utilities.nameTags)continue;"])
-        //.set("inView", [/(\w+\['\w+']\){if\(\(\w+=\w+\['\w+']\['position']\['clone']\(\))/, "(void 0 == window.utilities.nameTags)||$1"])
-        .set("inView", [/&&(\w+\['\w+'])\){(if\(\(\w+=\w+\['\w+']\['\w+']\['\w+'])/, "){if(!$1&&void 0 !== window.utilities.nameTags)continue;$2"])
-        .set("inputs", [/(\w+\['\w+']\[\w+\['\w+']\['\w+']\?'\w+':'push']\()(\w+)\),/, `$1window.utilities.onInput($2)),`])
-        //.set("procInputs", [/(this\['\w+']\()(this\['inputs']\[\w+])(,\w+,!0x1,!\w+|\|\w+\['moveLock']\))/, `$1window.utilities.onInput($2)$3`])
-
-        //.set("procInputs", [/this\['meleeAnim']\['armS']=0x0;},this\['\w+']=function\((\w+),\w+,\w+,\w+\){/, `$&window.cheat.onInput($1);`])
-        //.set("wallBangs", [/!(\w+)\['transparent']/, "$&& (!cheat.settings.wallbangs || !$1.penetrable )"])
-        .set("thirdPerson", [/(\w+)\[\'config\'\]\[\'thirdPerson\'\]/g, `void 0 !== window.utilities.thirdPerson`])
-        //.set("onRender", [/\w+\['render']=function\((\w+,\w+,\w+,\w+,\w+,\w+,\w+,\w+)\){/, `$&window.cheat.onRender($1);`])
-        .set("isHacker", [/(window\['\w+']=)!0x0\)/, `$1!0x1)`])
-        //.set("Damage", [/\['send']\('vtw',(\w+)\)/, `['send']('kpd',$1)`])
-        .set("fixHowler", [/(Howler\['orientation'](.+?)\)\),)/, ``])
-        .set("respawnT", [/'\w+':0x3e8\*/g, `'respawnT':0x0*`])
-        .set("anticheat", [/windows\['length'\]>\d+.*?0x25/, `0x25`])
-        //.set("FPS", [/(window\['mozRequestAnimationFrame']\|\|function\(\w+\){window\['setTimeout'])\(\w+,0x3e8\/0x3c\);/, "$1()"])
-        //.set("Update", [/(\w+=window\['setTimeout']\(function\(\){\w+)\((\w+)\+(\w+)\)/, "$1($2=$3=0)"])
-       // .set("weaponZoom", [/(,'zoom':)(\d.+?),/g, "$1window.utilities.settings.weaponZoom.val||$2"])
-
-        console.groupCollapsed("PATCHING");
-        let string = this.script;
-        for (let [name, arr] of patches) {
-            let found = arr[0].exec(string);
-            if (found) {
-                console.groupCollapsed(name);
-                for (let i = 0; i < found.length; ++i) {
-                    if (i == 0) {
-                        console.log("Regex ", arr[0]);
-                        console.log("Found ", found[i]);
-                        console.log("Index ", found.index);
-                    } else console.log("$", i, " ", found[i]);
-                }
-                console.log("Replace " + arr[1]);
-                const patched = string.substr(0, found.index) + String.prototype.replace.call( string.substr(found.index, string.length), arr[0], arr[1] );
-                if (string === patched) {
-                    alert(`Failed to patch ${name}`);
-                    continue;
-                } else {
-                    string = patched;
-                    console.log("patched");
-                }
-                console.groupEnd();
-            } else {
-                alert("Failed to find " + name);
-            }
-        }
-        console.groupEnd();
-        /*Lemons1337*/string = string.replace(/\[(0x[a-zA-Z0-9]+,?)+]\['map']\(\w+=>String\['fromCharCode']\(\w+\)\)\['join']\(''\)/g, a => "'" + w.eval(a) + "'");
-        const spoonter = `console.log("ahoy thar Skidney",'ðŸ’©');`
-        return spoonter + string;
-    }
-
-    deObfuscate() {
-        const obfu = {
-            //\]\)continue;if\(!\w+\['(.+?)\']\)continue;
-            inView: { regex: /(\w+\['(\w+)']\){if\(\(\w+=\w+\['\w+']\['position']\['clone']\(\))/, pos: 2 },
-
-            //inView: { regex: /\]\)continue;if\(!\w+\['(.+?)\']\)continue;/, pos: 1 },
-            //canSee: { regex: /\w+\['(\w+)']\(\w+,\w+\['x'],\w+\['y'],\w+\['z']\)\)&&/, pos: 1 },
-            //procInputs: { regex: /this\['(\w+)']=function\((\w+),(\w+),\w+,\w+\){(this)\['recon']/, pos: 1 },
-            aimVal: { regex: /this\['(\w+)']-=0x1\/\(this\['weapon']\['\w+']\/\w+\)/, pos: 1 },
-            pchObjc: { regex: /0x0,this\['(\w+)']=new \w+\['Object3D']\(\),this/, pos: 1 },
-            didShoot: { regex: /--,\w+\['(\w+)']=!0x0/, pos: 1 },
-            nAuto: { regex: /'Single\\x20Fire','varN':'(\w+)'/, pos: 1 },
-            crouchVal: { regex: /this\['(\w+)']\+=\w\['\w+']\*\w+,0x1<=this\['\w+']/, pos: 1 },
-            recoilAnimY: { regex: /\+\(-Math\['PI']\/0x4\*\w+\+\w+\['(\w+)']\*\w+\['\w+']\)\+/, pos: 1 },
-            //recoilAnimY: { regex: /this\['recoilAnim']=0x0,this\[(.*?\(''\))]/, pos: 1 },
-            ammos: { regex: /\['length'];for\(\w+=0x0;\w+<\w+\['(\w+)']\['length']/, pos: 1 },
-            weaponIndex: { regex: /\['weaponConfig']\[\w+]\['secondary']&&\(\w+\['(\w+)']==\w+/, pos: 1 },
-            isYou: { regex: /0x0,this\['(\w+)']=\w+,this\['\w+']=!0x0,this\['inputs']/, pos: 1 },
-            objInstances: { regex: /\w+\['\w+']\(0x0,0x0,0x0\);if\(\w+\['(\w+)']=\w+\['\w+']/, pos: 1 },
-            getWorldPosition: { regex: /{\w+=\w+\['camera']\['(\w+)']\(\);/, pos: 1 },
-            //mouseDownL: { regex: /this\['\w+'\]=function\(\){this\['(\w+)'\]=\w*0,this\['(\w+)'\]=\w*0,this\['\w+'\]={}/, pos: 1 },
-            mouseDownR: { regex: /this\['(\w+)']=0x0,this\['keys']=/, pos: 1 },
-            //reloadTimer: { regex:  /this\['(\w+)']&&\(\w+\['\w+']\(this\),\w+\['\w+']\(this\)/, pos: 1 },
-            maxHealth: { regex: /this\['health']\/this\['(\w+)']\?/, pos: 1 },
-            xDire: { regex: /this\['(\w+)']=Math\['lerpAngle']\(this\['xDir2']/, pos: 1 },
-            yDire: { regex: /this\['(\w+)']=Math\['lerpAngle']\(this\['yDir2']/, pos: 1 },
-            //xVel: { regex: /this\['x']\+=this\['(\w+)']\*\w+\['map']\['config']\['speedX']/, pos: 1 },
-            yVel: { regex: /this\['y']\+=this\['(\w+)']\*\w+\['map']\['config']\['speedY']/, pos: 1 },
-            //zVel: { regex: /this\['z']\+=this\['(\w+)']\*\w+\['map']\['config']\['speedZ']/, pos: 1 },
-        };
-        console.groupCollapsed("DEOBFUSCATE");
-        for (let key in obfu) {
-            let result = obfu[key].regex.exec(this.script);
-            if (result) {
-                window.utilities.vars[key] = result[obfu[key].pos];
-                console.log("found: ", key, " at ", result.index, " value: ", window.utilities.vars[key]);
-            } else {
-                const str = "Failed to find " + key;
-                console.error(str);
-                alert(str);
-                window.utilities.vars[key] = null;
-            }
-        }
-        console.groupEnd();
-    }
-
     onRender() { /* hrt / ttap - https://github.com/hrt */
         this.renderFrame ++;
         if (this.renderFrame >= 100000) this.renderFrame = 0;
         let scaledWidth = this.ctx.canvas.width / this.scale;
@@ -940,20 +937,8 @@
         let worldPosition = this.renderer.camera[this.vars.getWorldPosition]();
         let espVal = this.settings.renderESP.val;
         if (espVal ==="walls"||espVal ==="twoD") this.nameTags = undefined; else this.nameTags = true;
 
-        if (this.isNative(this.renderer.frustum.containsPoint)) {
-            this.renderer.frustum.containsPoint = function (point) {
-                let planes = this.planes;
-                for (let i = 0; i < 6; i ++) {
-                    if (planes[i].distanceToPoint(point) < 0) {
-                        return false;
-                    }
-                }
-                return true;
-            }
-        }
-
         if (this.settings.autoActivateNuke.val && this.me && Object.keys(this.me.streaks).length) { /*chonker*/
             this.ws.__send("k", 0);
         }
 
@@ -980,9 +965,9 @@
                         if (position = player[this.vars.objInstances].position.clone()) {
                             position.x += j * playerScale;
                             position.z += k * playerScale;
                             position.y += l * (player.height - player[this.vars.crouchVal] * this.consts.crouchDst);
-                            if (!this.renderer.frustum.containsPoint(position)) {
+                            if (!this.containsPoint(position)) {
                                 br = true;
                                 break;
                             }
                             position.project(this.renderer.camera);
@@ -1011,9 +996,9 @@
             const original_fillStyle = this.ctx.fillStyle;
 
             //Tracers
             if (this.settings.renderTracers.val) {
-                original_save.apply(this.ctx, []);
+                CRC2d.save.apply(this.ctx, []);
                 let screenPos = this.world2Screen(player[this.vars.objInstances].position);
                 this.ctx.lineWidth = 4.5;
                 this.ctx.beginPath();
                 this.ctx.moveTo(this.ctx.canvas.width/2, this.ctx.canvas.height - (this.ctx.canvas.height - scaledHeight));
@@ -1022,59 +1007,59 @@
                 this.ctx.stroke();
                 this.ctx.lineWidth = 2.5;
                 this.ctx.strokeStyle = this.settings.rainbowColor.val ? this.overlay.rainbow.col : "#eb5656"
                 this.ctx.stroke();
-                original_restore.apply(this.ctx, []);
+                CRC2d.restore.apply(this.ctx, []);
             }
 
-            original_save.apply(this.ctx, []);
+            CRC2d.save.apply(this.ctx, []);
             if (espVal == "twoD" || espVal == "full") {
                 // perfect box esp
                 this.ctx.lineWidth = 5;
                 this.ctx.strokeStyle = this.settings.rainbowColor.val ? this.overlay.rainbow.col : "#eb5656"
                 let distanceScale = Math.max(.3, 1 - this.getD3D(worldPosition.x, worldPosition.y, worldPosition.z, player.x, player.y, player.z) / 600);
-                original_scale.apply(this.ctx, [distanceScale, distanceScale]);
+                CRC2d.scale.apply(this.ctx, [distanceScale, distanceScale]);
                 let xScale = scaledWidth / distanceScale;
                 let yScale = scaledHeight / distanceScale;
-                original_beginPath.apply(this.ctx, []);
+                CRC2d.beginPath.apply(this.ctx, []);
                 ymin = yScale * (1 - ymin);
                 ymax = yScale * (1 - ymax);
                 xmin = xScale * xmin;
                 xmax = xScale * xmax;
-                original_moveTo.apply(this.ctx, [xmin, ymin]);
-                original_lineTo.apply(this.ctx, [xmin, ymax]);
-                original_lineTo.apply(this.ctx, [xmax, ymax]);
-                original_lineTo.apply(this.ctx, [xmax, ymin]);
-                original_lineTo.apply(this.ctx, [xmin, ymin]);
-                original_stroke.apply(this.ctx, []);
+                CRC2d.moveTo.apply(this.ctx, [xmin, ymin]);
+                CRC2d.lineTo.apply(this.ctx, [xmin, ymax]);
+                CRC2d.lineTo.apply(this.ctx, [xmax, ymax]);
+                CRC2d.lineTo.apply(this.ctx, [xmax, ymin]);
+                CRC2d.lineTo.apply(this.ctx, [xmin, ymin]);
+                CRC2d.stroke.apply(this.ctx, []);
 
                 if (espVal == "full") {
                     // health bar
                     this.ctx.fillStyle = "#000000";
                     let barMaxHeight = ymax - ymin;
-                    original_fillRect.apply(this.ctx, [xmin - 7, ymin, -10, barMaxHeight]);
+                    CRC2d.fillRect.apply(this.ctx, [xmin - 7, ymin, -10, barMaxHeight]);
                     this.ctx.fillStyle = player.health > 75 ? "green" : player.health > 40 ? "orange" : "red";
-                    original_fillRect.apply(this.ctx, [xmin - 7, ymin, -10, barMaxHeight * (player.health / player[this.vars.maxHealth])]);
+                    CRC2d.fillRect.apply(this.ctx, [xmin - 7, ymin, -10, barMaxHeight * (player.health / player[this.vars.maxHealth])]);
                     // info
                     this.ctx.font = "48px Sans-serif";
                     this.ctx.fillStyle = "white";
                     this.ctx.strokeStyle='black';
                     this.ctx.lineWidth = 1;
                     let x = xmax + 7;
                     let y = ymax;
-                    original_fillText.apply(this.ctx, [player.name||player.alias, x, y]);
-                    original_strokeText.apply(this.ctx, [player.name||player.alias, x, y]);
+                    CRC2d.fillText.apply(this.ctx, [player.name||player.alias, x, y]);
+                    CRC2d.strokeText.apply(this.ctx, [player.name||player.alias, x, y]);
                     this.ctx.font = "30px Sans-serif";
                     y += 35;
-                    original_fillText.apply(this.ctx, [player.weapon.name, x, y]);
-                    original_strokeText.apply(this.ctx, [player.weapon.name, x, y]);
+                    CRC2d.fillText.apply(this.ctx, [player.weapon.name, x, y]);
+                    CRC2d.strokeText.apply(this.ctx, [player.weapon.name, x, y]);
                     y += 35;
-                    original_fillText.apply(this.ctx, [player.health + ' HP', x, y]);
-                    original_strokeText.apply(this.ctx, [player.health + ' HP', x, y]);
+                    CRC2d.fillText.apply(this.ctx, [player.health + ' HP', x, y]);
+                    CRC2d.strokeText.apply(this.ctx, [player.health + ' HP', x, y]);
                 }
             }
 
-            original_restore.apply(this.ctx, []);
+            CRC2d.restore.apply(this.ctx, []);
             this.ctx.strokeStyle = original_strokeStyle;
             this.ctx.lineWidth = original_lineWidth;
             this.ctx.font = original_font;
             this.ctx.fillStyle = original_fillStyle;
@@ -1082,9 +1067,9 @@
             // skelly chams
             if (this.isDefined(player[this.vars.objInstances])) {
                 let obj = player[this.vars.objInstances];
                 if (!obj.visible) {
-                    original_Object.defineProperty(player[this.vars.objInstances], 'visible', {
+                    Object.defineProperty(player[this.vars.objInstances], 'visible', {
                         value: true,
                         writable: false
                     });
                 }
@@ -1092,15 +1077,15 @@
                     let chamColor = this.settings.renderChams.val;
                     let chamsEnabled = chamColor !== "off";
                     if (child && child.type == "Mesh" && child.material) {
                         child.material.depthTest = chamsEnabled ? false : true;
-                      if (this.isDefined(child.material.fog)) child.material.fog = chamsEnabled ? false : true;
-                      if (child.material.emissive) {
-                          child.material.emissive.r = chamColor == 'off' || chamColor == 'teal' || chamColor == 'green' || chamColor == 'blue' ? 0 : 0.55;
-                          child.material.emissive.g = chamColor == 'off' || chamColor == 'purple' || chamColor == 'blue' || chamColor == 'red' ? 0 : 0.55;
-                          child.material.emissive.b = chamColor == 'off' || chamColor == 'yellow' || chamColor == 'green' || chamColor == 'red' ? 0 : 0.55;
-                      }
-                      child.material.wireframe = this.settings.renderWireFrame.val ? true : false
+                        //if (this.isDefined(child.material.fog)) child.material.fog = chamsEnabled ? false : true;
+                        if (child.material.emissive) {
+                            child.material.emissive.r = chamColor == 'off' || chamColor == 'teal' || chamColor == 'green' || chamColor == 'blue' ? 0 : 0.55;
+                            child.material.emissive.g = chamColor == 'off' || chamColor == 'purple' || chamColor == 'blue' || chamColor == 'red' ? 0 : 0.55;
+                            child.material.emissive.b = chamColor == 'off' || chamColor == 'yellow' || chamColor == 'green' || chamColor == 'red' ? 0 : 0.55;
+                        }
+                        child.material.wireframe = this.settings.renderWireFrame.val ? true : false
                     }
                 })
             }
         }
@@ -1119,22 +1104,22 @@
     }
 
     raidBot(input) {
         let target = this.game.AI.ais.filter(enemy => {
-           return undefined !== enemy.mesh && enemy.mesh && enemy.mesh.children[0] && enemy.canBSeen && enemy.health > 0
+            return undefined !== enemy.mesh && enemy.mesh && enemy.mesh.children[0] && enemy.canBSeen && enemy.health > 0
         }).sort((p1, p2) => this.getD3D(this.me.x, this.me.z, p1.x, p1.z) - this.getD3D(this.me.x, this.me.z, p2.x, p2.z)).shift();
         if (target) {
-            let canSee = this.renderer.frustum.containsPoint(target.mesh.position)
+            let canSee = this.containsPoint(target.mesh.position)
             let yDire = (this.getDir(this.me.z, this.me.x, target.z, target.x) || 0)
             let xDire = ((this.getXDire(this.me.x, this.me.y, this.me.z, target.x, target.y + target.mesh.children[0].scale.y * 0.85, target.z) || 0) - this.consts.recoilMlt * this.me[this.vars.recoilAnimY])
-            if (this.me.weapon[this.vars.nAuto] && this.me[this.vars.didShoot]) { input[key.shoot] = 0; input[key.scope] = 0; this.me.inspecting = false; this.me.inspectX = 0; }
+            if (this.me.weapon[this.vars.nAuto] && this.me[this.vars.didShoot]) { input[this.key.shoot] = 0; input[this.key.scope] = 0; this.me.inspecting = false; this.me.inspectX = 0; }
             else {
                 if (!this.me.aimDir && canSee) {
-                    input[key.scope] = 1;
-                    if (!this.me[this.vars.aimVal]) {
-                        input[key.shoot] = 1;
-                        input[key.ydir] = yDire * 1e3
-                        input[key.xdir] = xDire * 1e3
+                    input[this.key.scope] = 1;
+                    if (!this.me[this.vars.aimVal]||this.me.weapon.noAim) {
+                        input[this.key.shoot] = 1;
+                        input[this.key.ydir] = yDire * 1e3
+                        input[this.key.xdir] = xDire * 1e3
                         this.lookDir(xDire, yDire);
                     }
                 }
             }
@@ -1152,58 +1137,34 @@
         }
         if (this.me) {
             this.inputFrame ++;
             if (this.inputFrame >= 100000) this.inputFrame = 0;
-            /*
-            if (!this.game.decreaseWeapon[isProxy]) {
-                this.game.decreaseWeapon = new original_Proxy(this.game.decreaseWeapon, {
+            if (!this.game.playerSound[this.isProxy]) {
+                this.game.playerSound = new Proxy(this.game.playerSound, {
                     apply: function(target, that, args) {
-                        if (args[0] == this.me) return;
+                        if (skid.settings.disableWpnSnd.val && args[0] && typeof args[0] == "string" && args[0].startsWith("weapon_")) return;
                         return target.apply(that, args);
                     },
                     get: function(target, key) {
-                        return key === isProxy ? true : Reflect.get(target, key);
+                        return key === skid.isProxy ? true : Reflect.get(target, key);
                     },
                 })
             }
-            if (!this.game.increaseWeapon[isProxy]) {
-                this.game.increaseWeapon = new original_Proxy(this.game.increaseWeapon, {
-                    apply: function(target, that, args) {
-                        if (args[0] !== this.me) return;
-                        return target.apply(that, args);
-                    },
-                    get: function(target, key) {
-                        return key === isProxy ? true : Reflect.get(target, key);
-                    },
-                })
-            }*/
 
-            if (!this.game.playerSound[isProxy]) {
-                this.game.playerSound = new original_Proxy(this.game.playerSound, {
-                    apply: function(target, that, args) {
-                        if (window.utilities.settings.disableWpnSnd.val && args[0] && typeof args[0] == "string" && args[0].startsWith("weapon_")) return;
-                        return target.apply(that, args);
-                    },
-                    get: function(target, key) {
-                        return key === isProxy ? true : Reflect.get(target, key);
-                    },
-                })
-            }
-
             let isMelee = this.isDefined(this.me.weapon.melee)&&this.me.weapon.melee||this.isDefined(this.me.weapon.canThrow)&&this.me.weapon.canThrow;
+            let ammoLeft = this.me[this.vars.ammos][this.me[this.vars.weaponIndex]];
 
             // autoReload
             if (this.settings.autoReload.val) {
-                let ammoLeft = this.me[this.vars.ammos][this.me[this.vars.weaponIndex]];
-                let capacity = this.me.weapon.ammo;
+                //let capacity = this.me.weapon.ammo;
                 //if (ammoLeft < capacity)
                 if (isMelee) {
                     if (!this.me.canThrow) {
                         //this.me.refillKnife();
                     }
                 } else if (!ammoLeft) {
                     this.game.players.reload(this.me);
-                    input[key.reload] = 1;
+                    input[this.key.reload] = 1;
                     // this.me[this.vars.reloadTimer] = 1;
                     //this.me.resetAmmo();
                 }
             }
@@ -1229,68 +1190,71 @@
             }
 
             //Autoaim
             if (this.settings.autoAim.val !== "off") {
+                this.playerMaps.length = 0;
+                this.rayC.setFromCamera(this.vec2, this.renderer.fpsCamera);
                 let target = this.game.players.list.filter(enemy => {
-                    return undefined !== enemy[this.vars.objInstances] && enemy[this.vars.objInstances] && !enemy[this.vars.isYou] && !this.getIsFriendly(enemy) && enemy.health > 0 && this.getInView(enemy)
+                    let hostile = undefined !== enemy[this.vars.objInstances] && enemy[this.vars.objInstances] && !enemy[this.vars.isYou] && !this.getIsFriendly(enemy) && enemy.health > 0 && this.getInView(enemy);
+                    if (hostile) this.playerMaps.push( enemy[this.vars.objInstances] );
+                    return hostile
                 }).sort((p1, p2) => this.getD3D(this.me.x, this.me.z, p1.x, p1.z) - this.getD3D(this.me.x, this.me.z, p2.x, p2.z)).shift();
                 if (target) {
                     //let count = this.spinTick(input);
                     //if (count < 360) {
                     //    input[2] = this.me[this.vars.xDire] + Math.PI;
                     //} else console.log("spins ", count);
                     //target.jumpBobY * this.config.jumpVel
-                    let canSee = this.renderer.frustum.containsPoint(target[this.vars.objInstances].position);
-                    let yDire = (this.getDir(this.me.z, this.me.x, target.z, target.x) || 0)
+                    let canSee = this.containsPoint(target[this.vars.objInstances].position);
+                    let inCast = this.rayC.intersectObjects(this.playerMaps, true).length;
+                    let yDire = (this.getDir(this.me.z, this.me.x, target.z, target.x) || 0);
                     let xDire = ((this.getXDire(this.me.x, this.me.y, this.me.z, target.x, target.y - target[this.vars.crouchVal] * this.consts.crouchDst + this.me[this.vars.crouchVal] * this.consts.crouchDst, target.z) || 0) - this.consts.recoilMlt * this.me[this.vars.recoilAnimY])
                     if (this.me.weapon[this.vars.nAuto] && this.me[this.vars.didShoot]) {
-                        input[key.shoot] = 0;
-                        input[key.scope] = 0;
+                        input[this.key.shoot] = 0;
+                        input[this.key.scope] = 0;
                         this.me.inspecting = false;
                         this.me.inspectX = 0;
                     }
                     else if (!canSee && this.settings.frustrumCheck.val) this.resetLookAt();
-                    else {
-                        input[key.scope] = this.settings.autoAim.val === "assist"||this.settings.autoAim.val === "correction" ? this.controls[this.vars.mouseDownR] : this.settings.autoAim.val === "trigger" ? canSee ? 1 : 0 : 1;
+                    else if (ammoLeft||isMelee) {
+                        input[this.key.scope] = this.settings.autoAim.val === "assist"||this.settings.autoAim.val === "correction"||this.settings.autoAim.val === "trigger" ? this.controls[this.vars.mouseDownR] : 0;
                         switch (this.settings.autoAim.val) {
                             case "quickScope":
-                                input[key.scope] = 1;
-                                if (!this.me[this.vars.aimVal]) {
-                                    if (!this.me.canThrow||!isMelee) input[key.shoot] = 1;
-                                    input[key.ydir] = yDire * 1e3
-                                    input[key.xdir] = xDire * 1e3
+                                input[this.key.scope] = 1;
+                                if (!this.me[this.vars.aimVal]||this.me.weapon.noAim) {
+                                    if (!this.me.canThrow||!isMelee) input[this.key.shoot] = 1;
+                                    input[this.key.ydir] = yDire * 1e3
+                                    input[this.key.xdir] = xDire * 1e3
                                     this.lookDir(xDire, yDire);
                                 }
                                 break;
                             case "assist": case "easyassist":
-                                if (input[key.scope] || this.settings.autoAim.val === "easyassist") {
+                                if (input[this.key.scope] || this.settings.autoAim.val === "easyassist") {
                                     if (!this.me.aimDir && canSee || this.settings.autoAim.val === "easyassist") {
-                                        input[key.ydir] = yDire * 1e3
-                                        input[key.xdir] = xDire * 1e3
+                                        input[this.key.ydir] = yDire * 1e3
+                                        input[this.key.xdir] = xDire * 1e3
                                         this.lookDir(xDire, yDire);
                                     }
                                 }
                                 break;
                             case "silent":
-                                if (!this.me[this.vars.aimVal]) {
-                                    if (!this.me.canThrow||!isMelee) input[key.shoot] = 1;
-                                } else input[key.scope] = 1;
-                                input[key.ydir] = yDire * 1e3
-                                input[key.xdir] = xDire * 1e3
+                                if (!this.me[this.vars.aimVal]||this.me.weapon.noAim) {
+                                    if (!this.me.canThrow||!isMelee) input[this.key.shoot] = 1;
+                                } else input[this.key.scope] = 1;
+                                input[this.key.ydir] = yDire * 1e3
+                                input[this.key.xdir] = xDire * 1e3
                                 break;
                             case "trigger":
-                                if (!this.me.aimDir) {
-                                    if (!this.me[this.vars.aimVal] && this.me.aimTime > 180) {
-                                        if (!this.me.canThrow) input[key.shoot] = 1;
-                                        input[key.ydir] = yDire * 1e3
-                                        input[key.xdir] = xDire * 1e3
-                                    }
+                                if (input[this.key.scope] && canSee && inCast) {
+                                    input[this.key.shoot] = 1;
+                                    input[this.key.ydir] = yDire * 1e3
+                                    input[this.key.xdir] = xDire * 1e3
                                 }
                                 break;
                             case "correction":
-                                if (input[key.shoot] == 1) {
-                                    input[key.ydir] = yDire * 1e3
-                                    input[key.xdir] = xDire * 1e3
+                                if (input[this.key.shoot] == 1) {
+                                    input[this.key.ydir] = yDire * 1e3
+                                    input[this.key.xdir] = xDire * 1e3
                                 }
                                 break;
                             default:
                                 this.resetLookAt();
@@ -1304,20 +1268,16 @@
             }
         }
 
         //else if (this.settings.autoClick.val && !this.ui.hasEndScreen) {
-            //this.config.deathDelay = 0;
-            //this.controls.toggle(true);
+        //this.config.deathDelay = 0;
+        //this.controls.toggle(true);
         //}
 
         //this.game.config.deltaMlt = 1
         return input;
     }
 
-    getAngleDst(a, b) {
-        return Math.atan2(Math.sin(b - a), Math.cos(a - b));
-    };
-
     getD3D(x1, y1, z1, x2, y2, z2) {
         let dx = x1 - x2;
         let dy = y1 - y2;
         let dz = z1 - z2;
@@ -1341,8 +1301,18 @@
     getDistance(x1, y1, x2, y2) {
         return Math.sqrt((x2 -= x1) * x2 + (y2 -= y1) * y2);
     }
 
+    containsPoint(point) {
+        let planes = this.renderer.frustum.planes;
+        for (let i = 0; i < 6; i ++) {
+            if (planes[i].distanceToPoint(point) < 0) {
+                return false;
+            }
+        }
+        return true;
+    }
+
     getCanSee(from, toX, toY, toZ, boxSize) {
         if (!from) return 0;
         boxSize = boxSize||0;
         for (let obj, dist = this.getD3D(from.x, from.y, from.z, toX, toY, toZ), xDr = this.getDir(from.z, from.x, toZ, toX), yDr = this.getDir(this.getDistance(from.x, from.z, toX, toZ), toY, 0, from.y), dx = 1 / (dist * Math.sin(xDr - Math.PI) * Math.cos(yDr)), dz = 1 / (dist * Math.cos(xDr - Math.PI) * Math.cos(yDr)), dy = 1 / (dist * Math.sin(yDr)), yOffset = from.y + (from.height || 0) - this.consts.cameraHeight, aa = 0; aa < this.game.map.manager.objects.length; ++aa) {
@@ -1354,9 +1324,9 @@
         /*
         let terrain = this.game.map.terrain;
         if (terrain) {
             let terrainRaycast = terrain.raycast(from.x, -from.z, yOffset, 1 / dx, -1 / dz, 1 / dy);
-            if (terrainRaycast) return this.getD3D(from.x, from.y, from.z, terrainRaycast.x, terrainRaycast.z, -terrainRaycast.y);
+            if (terrainRaycast) return utl.getD3D(from.x, from.y, from.z, terrainRaycast.x, terrainRaycast.z, -terrainRaycast.y);
         }
         */
         return null;
     }
@@ -1412,90 +1382,196 @@
         return (this.me && this.me.team ? this.me.team : this.me.spectating ? 0x1 : 0x0) == entity.team
     }
 }
 
-(function() {
-    //'use strict';
-    let initialize = function() {
+function loadWASM() {
+    window.Function = new Proxy(window.Function, {
+        construct(target, args) {
+            const original = new target(...args);
+            if (args.length) {
+                let body = args[args.length - 1];
+                if (body.length > 38e5) {
+                    // game.js at game loader Easy Method
+                    //console.log(body)
+                }
+                else if (args[0] == "requireRegisteredType") {
+                    return (function(...fnArgs){
+                        // Expose WASM functions
+                        if (!window.hasOwnProperty("WASM")) {
+                            window.Object.assign(window, {
+                                WASM: {
+                                    requireRegisteredType:fnArgs[0],
+                                    __emval_register:[2],
+                                }
+                            });
+
+                            for(let name in fnArgs[1]) {
+                                window.WASM[name] = fnArgs[1][name];
+                                switch (name) {
+                                    case "__Z01dynCall_fijfiv": //game.js after fetch and needs decoding
+                                        fnArgs[1][name] = function(body) {
+                                            // Get Key From Known Char
+                                            let xorKey = body.charCodeAt() ^ '!'.charCodeAt(), str = "", ret ="";
+
+                                            // Decode Mangled String
+                                            for (let i = 0, strLen = body.length; i < strLen; i++) {
+                                                str += String.fromCharCode(body.charCodeAt(i) ^ xorKey);
+                                            }
+
+                                            // Manipulate String
+                                            //console.log(str)
+                                            window[skidStr] = new Skid();
+                                            str = skid.gameJS(str);
+
+                                            //ReEncode Mangled String
+                                            for (let i = 0, strLen = str.length; i < strLen; i++) {
+                                                ret += String.fromCharCode(str[i].charCodeAt() ^ xorKey);
+                                            }
+
+                                            // Return With Our Manipulated Code
+                                            return window.WASM[name].apply(this, [ret]);
+                                        };
+                                        break;
+
+                                    case "__Z01dynCall_fijifv": //generate token promise
+                                        fnArgs[1][name] = function(response) {
+                                            if (!response.ok) {
+                                                throw new window.Error("Network response from " + response.url + " was not ok")
+                                            }
+                                            let promise = window.WASM[name].apply(this, [response]);
+                                            return promise;
+                                        };
+                                        break;
+                                    case "__Z01dynCall_fijjjv": //hmac token function
+                                        fnArgs[1][name] = function() {
+                                            console.log(arguments[0]);
+                                            return window.WASM[name].apply(this, arguments);
+                                        };
+                                        break;
+
+                                }
+                            }
+                        }
+                        return new target(...args).apply(this, fnArgs);
+                    })
+                }
+                // If changed return with spoofed toString();
+                if (args[args.length - 1] !== body) {
+                    args[args.length - 1] = body;
+                    let patched = new target(...args);
+                    patched.toString = () => original.toString();
+                    return patched;
+                }
+            }
+            return original;
+        }
+    })
+
\ No newline at end of file
+    function onPageLoad() {
+        window.instructionHolder.style.display = "block";
+        window.instructions.innerHTML = `<div id="settHolder"><img src="https://i.imgur.com/yzb2ZmS.gif" width="25%"></div><a href='https://skidlamer.github.io/wp/' target='_blank.'><div class="imageButton discordSocial"></div></a>`
+        window.request = (url, type, opt = {}) => fetch(url, opt).then(response => response.ok ? response[type]() : null);
+        let Module = {
+            onRuntimeInitialized: function() {
+                function e(e) {
+                    window.instructionHolder.style.display = "block";
+                    window.instructions.innerHTML = "<div style='color: rgba(255, 255, 255, 0.6)'>" + e + "</div><div style='margin-top:10px;font-size:20px;color:rgba(255,255,255,0.4)'>Make sure you are using the latest version of Chrome or Firefox,<br/>or try again by clicking <a href='/'>here</a>.</div>";
+                    window.instructionHolder.style.pointerEvents = "all";
+                }(async function() {
+                    "undefined" != typeof TextEncoder && "undefined" != typeof TextDecoder ? await Module.initialize(Module) : e("Your browser is not supported.")
+                })().catch(err => {
+                    e("Failed to load game.");
+                    throw new Error(err);
+                })
+            }
+        };
         window._debugTimeStart = Date.now();
-        fetch(location.origin+"/pkg/maindemo.wasm", {
-            cache: "no-store"
-        }).then(res=>res.arrayBuffer()).then(buff=>{
-            window.mod.wasmBinary = buff;
-            fetch(location.origin+"/pkg/maindemo.js", {
-                cache: "no-store"
-            }).then(res=>res.text()).then(body=>{
+        window.request("/pkg/maindemo.wasm","arrayBuffer",{cache: "no-store"}).then(body => {
+            Module.wasmBinary = body;
+            window.request("/pkg/maindemo.js","text",{cache: "no-store"}).then(body => {
                 body = body.replace(/(function UTF8ToString\((\w+),\w+\)){return \w+\?(.+?)\}/, `$1{let str=$2?$3;if (str.includes("CLEAN_WINDOW") || str.includes("Array.prototype.filter = undefined")) return "";return str;}`);
                 body = body.replace(/(_emscripten_run_script\(\w+\){)eval\((\w+\(\w+\))\)}/, `$1 let str=$2; console.log(str);}`);
-                //body = body.replace(/return (UTF8Decoder\.decode\(heap.subarray\(idx,endPtr\)\))/, `let outStr = $1; if (outStr.startsWith("var vrtInit"))outStr = window.mod.patchScript(outStr);else console.log(outStr); return outStr`);
-                //body = body.replace(/return (stringToUTF8Array\(str,HEAPU8,outPtr,maxBytesToWrite\))/, `if(str.length>4e6)str = window.mod.patchScript(str);else console.log(str); return $1`);
-                //body = body.replace(/(function UTF8ToString\((\w+),\w+\)){return \w+\?(.+?)\}/, `$1{let str=$2?$3;if (str.includes("CLEAN_WINDOW") || str.includes("Array.prototype.filter = undefined")) return "";else if (str.startsWith("var vrtInit")) str = window.mod.patchScript(str);return str;}`);
                 new Function(body)();
-                window.initWASM(window.mod);
-                window.mod.onRuntimeInitialized = async function(){
-                    "undefined" != typeof TextEncoder && "undefined" != typeof TextDecoder ? await this.initialize(this) : this.errorMsg("Your browser is not supported.")
-                }
+                window.initWASM(Module);
             })
         });
+    }
 
-        window.Function = new Proxy(Function, {
-            construct(target, args) {
-                const that = new target(...args);
-                if (args.length) {
-                    let string = args[args.length - 1];
+    let observer = new MutationObserver(mutations => {
+        for (let mutation of mutations) {
+            for (let node of mutation.addedNodes) {
+                if (node.tagName === 'SCRIPT' && node.type === "text/javascript" && node.innerHTML.startsWith("*!", 1)) {
+                    observer.disconnect();
+                    node.innerHTML = onPageLoad.toString() + "\nonPageLoad();";
+                }
+            }
+        }
+    });
 
-                    if (string.length > 38e5) {
-                        window.utilities = new Utilities(string);
-                        string = window.utilities.patchScript();
-                    }
+    observer.observe(document, {
+        childList: true,
+        subtree: true
+    });
+}
 
-                    // If changed return with spoofed toString();
-                    if (args[args.length - 1] !== string) {
-                        args[args.length - 1] = string;
-                        let patched = new target(...args);
-                        patched.toString = () => that.toString();
-                        return patched;
-                    }
-                }
-                return that;
+function loadBasic() {
+    let request = async function(url, type, opt = {}) {
+        return fetch(url, opt).then(response => {
+            if (!response.ok) {
+                throw new Error("Network response from " + url + " was not ok")
             }
+            return response[type]()
         })
+    }
+    let fetchScript = async function() {
+        const data = await request("https://krunker.io/social.html", "text");
+        const buffer = await request("https://krunker.io/pkg/krunker." + /\w.exports="(\w+)"/.exec(data)[1] + ".vries", "arrayBuffer");
+        const array = Array.from(new Uint8Array(buffer));
+        const xor = array[0] ^ '!'.charCodeAt(0);
+        return array.map((code) => String.fromCharCode(code ^ xor)).join('');
+    }
 
-        CanvasRenderingContext2D.prototype.clearRect = function(x, y, width, height) {
-            original_clearRect.apply(this, [x, y, width, height]);
-            if (void 0 !== window.utilities) window.utilities.ctx = this;
-            (function() {
-                const caller = arguments.callee.caller.caller;
-                if (caller) {
-                    const renderArgs = caller.arguments;
-                    if (renderArgs && void 0 !== window.utilities && window.utilities) {
-                        ["scale", "game", "controls", "renderer", "me"].forEach((item, index)=>{
-                            window.utilities[item] = renderArgs[index];
-                        });
-                        if (renderArgs[4]) {
-                            window.utilities.onRender();
-                            //window.requestAnimationFrame.call(window, renderArgs.callee.caller.bind(this));
-                        }
-                        if(window.utilities.settings && window.utilities.settings.autoClick.val && window.endUI.style.display == "none" && window.windowHolder.style.display == "none") {
-                            renderArgs[2].toggle(true);
-                        }
-                    }
-                }
-            })();
-        }
+    function onPageLoad() {
+        window.instructionHolder.style.display = "block";
+        window.instructions.innerHTML = `<div id="settHolder"><img src="https://i.imgur.com/yzb2ZmS.gif" width="25%"></div><a href='https://skidlamer.github.io/wp/' target='_blank.'><div class="imageButton discordSocial"></div></a>`
+        window.instructionHolder.style.pointerEvents = "all";
+        window._debugTimeStart = Date.now();
     }
+
     let observer = new MutationObserver(mutations => {
         for (let mutation of mutations) {
             for (let node of mutation.addedNodes) {
                 if (node.tagName === 'SCRIPT' && node.type === "text/javascript" && node.innerHTML.startsWith("*!", 1)) {
-                    node.innerHTML = `!function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t){window.mod={errorMsg:function(i){instructionHolder.style.display="block",instructions.innerHTML="<div style='color: rgba(255, 255, 255, 0.6)'>"+i+"</div><div style='margin-top:10px;font-size:20px;color:rgba(255,255,255,0.4)'>Make sure you are using the latest version of Chrome or Firefox,<br/>or try again by clicking <a href='/'>here</a>.</div>",instructionHolder.style.pointerEvents="all"}};}]);`
-                    initialize();
                     observer.disconnect();
+                    node.innerHTML = onPageLoad.toString() + "\nonPageLoad();";
+                    fetchScript().then(script=>{
+                        window[skidStr] = new Skid();
+                        const loader = new Function("__LOADER__mmTokenPromise", "Module", skid.gameJS(script));
+                        loader(new Promise(res=>res(JSON.parse(xhr.responseText).token)), { csv: async () => 0 });
+                        window.instructionHolder.style.pointerEvents = "none";
+                    })
                 }
             }
         }
     });
+
     observer.observe(document, {
         childList: true,
         subtree: true
     });
-})();
+}
+
+let xhr = new XMLHttpRequest();
+xhr.open('GET', 'https://api.sys32.dev/token', false);
+
+try {
+  xhr.send();
+  if (xhr.status != 200) {
+      loadWASM();
+  } else {
+      if (xhr.responseText.includes('success')) {
+          loadBasic();
+      } else loadWASM();
+  }
+} catch(err) {
+    loadWASM();
+}
